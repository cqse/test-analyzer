package de.tum.in.niedermr.ta.runner.configuration;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.tum.in.niedermr.ta.core.common.constants.FileSystemConstants;
import de.tum.in.niedermr.ta.core.common.io.TextFileData;
import de.tum.in.niedermr.ta.runner.configuration.exceptions.ConfigurationException;
import de.tum.in.niedermr.ta.runner.configuration.parser.ConfigurationParser;
import de.tum.in.niedermr.ta.runner.configuration.parser.IConfigurationTokens;
import de.tum.in.niedermr.ta.runner.configuration.property.templates.IConfigurationProperty;

/**
 * Load a configuration from a file.<br/>
 * <br/>
 * 
 * Comments can be specified using {@link COMMENT_START_SEQ_1} or {@link COMMENT_START_SEQ_2}.<br/>
 * A configuration file can extend another one. To do so, the first line must start with <code>extends</code> followed
 * by a space and the path to the configuration file to be inherited. The path is supposed to be relative to the current
 * configuration file.
 */
public class ConfigurationManager implements FileSystemConstants {
	/** Logger. */
	private static final Logger LOGGER = LogManager.getLogger(ConfigurationManager.class);

	/** Constructor. */
	private ConfigurationManager() {
		// NOP
	}

	public static Configuration loadConfiguration() throws ConfigurationException, FileNotFoundException {
		try {
			// don't close sc, because it will close System.in (and that can't be reopened)
			@SuppressWarnings("resource")
			Scanner sc = new Scanner(System.in);

			System.out.println("Path to configuration file:");
			String fileName = sc.nextLine();
			return loadConfigurationFromFile(fileName, ".");
		} catch (FileNotFoundException e) {
			throw e;
		} catch (Exception e) {
			throw new ConfigurationException(e);
		}
	}

	public static Configuration loadConfigurationFromFile(String configurationFileName)
			throws ConfigurationException, IOException {
		return loadConfigurationFromFile(configurationFileName, "");
	}

	public static Configuration loadConfigurationFromFile(String configurationFileName, String rootPath)
			throws ConfigurationException, IOException {
		LOGGER.info("Configuration from file ('" + configurationFileName + "' in '" + rootPath + "')");

		File configFile = new File(configurationFileName);
		String pathToConfiguration;

		if (configFile.isAbsolute()) {
			pathToConfiguration = configurationFileName;
		} else {
			pathToConfiguration = rootPath + configurationFileName;
		}

		try {
			return ConfigurationParser.parseFromFile(pathToConfiguration);
		} catch (FileNotFoundException ex) {
			LOGGER.info(
					"Assumed absolute path to configuration file: " + new File(pathToConfiguration).getAbsolutePath());
			throw ex;
		}
	}

	public static List<String> toFileLines(Configuration configuration, boolean includeDescriptionAsComment) {
		List<String> result = new LinkedList<>();

		result.add(IConfigurationTokens.COMMENT_START_SEQ_1 + " AUTOGENERATED");

		for (IConfigurationProperty<?> property : configuration.getAllPropertiesOrdered()) {
			if (includeDescriptionAsComment) {
				result.add(IConfigurationTokens.COMMENT_START_SEQ_1 + " " + property.getDescription());
			}

			result.add(property.getName() + IConfigurationTokens.KEY_VALUE_SEPARATOR_SET + property.getValueAsString());
		}

		result.addAll(configuration.getDynamicValues().toStringLines());

		return result;
	}

	public static void writeToFile(Configuration configuration, String file) throws IOException {
		TextFileData.writeToFile(file, toFileLines(configuration, false));
	}
}
